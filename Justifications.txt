* Why doesn't lima allow keyword operators (like x in y)?
	* This can cause confusing problems when a variable of the same name is declared in scope, e.g. if b is an operator for a and c
		var b = 5
		var list = {a b c} ;; is a list of one value
		var list = {a b}   ;; could be a list of one or two values depending on if b is a unary operator

* Any operators that need to operate on all values in the same way shouldn't be overloadable (= | ?? round-parens)
* the square bracket operator is special because you want to be able to do stuff like object[!A] without making it a [! operator all the time

* All objects in Lima modules should be able to access all members (including private ones) so the programmer has full control over how they want to modularize their code. Doesn't make sense to necessarily force them to put functionality in static classes or something. Also, if they're all in the same file, you ensure that it really is part of the same project. You also limit the scope to the amount that a programmer is willing to put in to a single file.


* There is no difference between compile time paths and runtime paths
	* Just like there's no difference between compile time and runtime in general
	* lima will be built into a separate build folder in the directory of the main lima source file

* Object resurrection is disallowed because of:
	* ambiguities about when to run the destructor
	* confusing code that comes out of it

* Difference between privilaged and non-privilaged members is necessary because without such a distinction, there would be no way of creating the right namespaces to have a hashmap, for example. You would have to always use the bracket-operator for hashmap members, and the dot operator for the hashmap's methods and such
	* Even that may not be enough, because even the underlying object that holds the hashmap's values should have a length
	* It just gets you deeper and deeper into trouble if you combine those namespaces

* The `inherit` meta property was created to facilitate overriding how properties are inherited. Before this property was created, I envisioned a `fixed` custom function that would create a "static member" of an object that would be shared across instances, but when inherited would create a copy. This way you could keep track of class-specific things. This probably isn't that useful usually tho, so I removed it, but added a way to implement it in user-space if need be.

* Being able to throw an exception at an arbitrary point within a running continuation is necessary for doing things like cancelation of functions you haven't written (eg module functions) without them having to explicitly support cancelation. This is how you would do the sort of thing in lima that bluebird cancellation does with javascript futures, for example.

* Digits in numbers can be separated by single-quotes like 234'345 so that you can group numbers in a way that makes them more readable, for example grouping digits in threes to indicate orders of 1000, or grouping hexadecimal numbers in twos to indicate bytes or fours to indicate each 2 bytes. Single-quotes are used rather than commas because commas look too much like dots and are used in some langauges to indicate the decimal place AND because most other languages use them as list separators so it would be confusing. So for visual contrast and minimizing confusion, the single-quote is used for that.

* while and df *should* create new scopes so people don't get confused when variables would change out from under them in asynchronous callbacks. Read: https://blogs.msdn.microsoft.com/ericlippert/2009/11/12/closing-over-the-loop-variable-considered-harmful/